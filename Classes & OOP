/******************************************************************************
Object Oriented Programming
3 primazry principles: Encapsulation, Inheritance, Polymorphism

Encapsulation unites behaviors and data into an object.
Encapsulation provides security via information hiding and protecting data from -
              the outside world.
              Provides portability as we can move an object around.
              A Class acts as a blueprint for an object.
*******************************************************************************/

#include <iostream>
#include <string>

using namespace std;

// Just like in Java, "Public" and "Private" are Access Modifiers (or Access Specifiers.)
class House {

    // Member/Member funtions: (Same thing as a Java methods.)
    //   They can be defined as a behavior that belongs to a class.

    // Setters can also be called "mutators." Getters can also be called "accessors."
public: 
    void setNumStories(int numStories)
    {
        /* The "this" keyword:
        * If you want to refer to data members from inside one of the classes methods, you can
        * use the this keyword. Since the parameter name is the same as the data member, we have
        * to use the "this" keyword. Doing this allows the parameter to eclipse or overshadow
        * the data member of the same name, AKA "name shadowing." You could just name them
        * different things, and now you don't have to use "this" but name shadowing is the 
        * preferred way. (Reusing the data member's name as the parameter name is cleaner)
        */
        this->numStories = numStories;
    }

    void setNumWindows(int numWindows)
    {
        this->numWindows = numWindows;
    }

    void setColor(string color)
    {
        this->color = color;
    }

    /* We don't have to write const after the getter methods, but it is considered good
    * software engineering to only give a method as much access as it needs and no more.
    * In the context of writing const after a member function header like below, we make it
    * so the method has access to the data members, but cannot change them. Since getters only
    * return and display the value this is perfect.
    * If a setter had const after it, we would get a compile time error due to not being able
    * to change the private data. Methods act like gate keepers of the data.
    */
    int getNumStories() const
    {
        return numStories;
    }

    int getNumWindows() const
    {
        return numWindows;
    }

    string getColor() const
    {
        return color;
    }
// Can be called Data Members OR Fields. They are initially only accessible in the class itself.
// To use Private Data Members outside of the class, write a setter and getter method like above.
private:
    int numStories;
    int numWindows;
    string color;

}; //end of the class House


int main()
{
    House myHouse;
    House yourHouse;

    myHouse.setColor("blue");
    myHouse.setNumStories(2);

    cout << "My house is " << myHouse.getNumStories() << " stories." << endl;
    cout << "My house is the color " << myHouse.getColor() << "." << endl;

    return 0;
}
